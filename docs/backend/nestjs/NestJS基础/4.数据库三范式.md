### 一.第一范式（1NF）

------

**如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式(1NF)。**

在关系型数据库的设计中，满足第一范式(1NF)是数据库设计的基本要求，也就是说只有满足了第一范式(1NF)的数据库才能叫做关系数据库。

满足第一范式的目的就是**确保每列保持原子性**。

> 例子1：设计一张“员工”表，设计如下：

| **empId** | **empName** | **age** | sex  | **address**  |
| --------- | ----------- | ------- | ---- | ------------ |
| 1         | 小朱        | 23      | m    | 山东省淄博市 |
| 2         | 小鲁        | 36      | f    | 浙江省绍兴市 |
| 3         | 小张        | 18      | m    | 江苏省扬州市 |

这张表的设计就不符合第一范式(1NF)，因为“地址”这个属性可以继续拆分成“省份”和“城市”两个属性，假设有一天公司需要统计来自某个省份或者某个城市的所有员工信息的话，这样分类就非常方便了。

> 满足第一范式(1NF)的员工表重新设计如下：

| **empId** | **empName** | **age** | sex  | **province** | **city** |
| --------- | ----------- | ------- | ---- | ------------ | -------- |
| 1         | 小朱        | 23      | m    | 山东省       | 淄博市   |
| 2         | 小鲁        | 36      | f    | 浙江省       | 绍兴市   |
| 3         | 小张        | 18      | m    | 江苏省       | 扬州市   |

### 二.第二范式(2NF)

------

第二范式(2NF)是在第一范式(1NF)的基础之上更进一步，对记录的`唯一性`。第二范式需要确保数据库表中的每一列都和`主键`相关，而不能只与`主键`的某一部分相关(主要针对联合主键而言)。也就是说在一个数据库表中，**一个表中只能保存一种`数据`，不可以把多种数据保存在同一张数据库表中**。

> 比如有一张“学生课程成绩”表：

| **stuId** | **stuName** | **age** | sex  | **courseId** | **courseName** | **score** | **credit** |
| --------- | ----------- | ------- | ---- | ------------ | -------------- | --------- | ---------- |
| 1         | 小朱        | 23      | m    | 1            | 数学           | 99        | 2          |
| 1         | 小朱        | 23      | f    | 2            | 语文           | 89        | 3          |
| 2         | 小鲁        | 36      | f    | 2            | 语文           | 78        | 3          |
| 3         | 小张        | 18      | m    | 1            | 数学           | 88        | 2          |

如果我们想从上面这张表中获取某个学生的某门成绩，只靠 `stuId` 或者 `courseId` 是没有办法唯一确定某个学生的某门课程成绩的，因此需要将 `stdId` 和 `courseId` 作为“学生课程成绩表”的**联合主键**，通过联合主键才能唯一确定某个学生的某门课程成绩。

在应用中使用以上关系模式会存在以下问题：

- **数据冗余**：同一门课程的“学分(credit)”是和课程相关的，如果在一张表里记录了30条学生成绩，学分(credit)”也就重复了30次，造成数据冗余。
- **更新异常**：如果某一门课程的学分调整了，那么需要调整“学生课程成绩”表里涉及到的所有数据，容易造成数据的漏改、错改。
- **插入异常**：如果这时候新开了一门课程，但是由于这门课程还没有人选，学生信息只能等到有人选修的时候再插入了，会导致数据的插入异常。
- **删除异常**：如果某个学生已经结业，需要删除该学生的成绩记录，同时会删除课程信息以及该课程的学分信息，这时候如果该门课还没有新生选修就会导致课程信息丢失，造成数据保存失败。

再仔细观察这张表的信息，`stuName`、`age`、`sex` 只与 `stuId` 相关，`courseName` 只与 `courseId` 相关，和第二范式(2NF)中规定的**需要确保数据库表中的每一列都和主键相关**这个规则相违背，所以上述这张表的设计不符合第二范式(2NF)。

**那么如何调整才能让其符合第二范式(2NF)呢？**

可以将上述“学生课程成绩表”拆分成“学生”表、“课程”表和“学生课程成绩”表。

> “学生”表：

| **stuId** | **stuName** | **age** | sex  |
| --------- | ----------- | ------- | ---- |
| 1         | 小朱        | 23      | m    |
| 1         | 小朱        | 23      | f    |
| 2         | 小鲁        | 36      | f    |
| 3         | 小张        | 18      | m    |

> ”课程“表

| **courseId** | **courseName** | **credit** |
| ------------ | -------------- | ---------- |
| 1            | 数学           | 2          |
| 2            | 语文           | 3          |
| 2            | 语文           | 3          |
| 1            | 数学           | 2          |

> “学生课程成绩”表：

| **stuId** | **courseId** | **score** | **credit** |
| --------- | ------------ | --------- | ---------- |
| 1         | 1            | 99        | 2          |
| 1         | 2            | 89        | 3          |
| 2         | 2            | 78        | 3          |
| 3         | 1            | 88        | 2          |

> 调整后的模型如下：

![student_course.png](https://cdn.jsdelivr.net/gh/zhu325/markdown-img/blog/5fb108699ffe4bd193451ccdb7ce6a7d~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp)

通过上述将一张表拆分成多张表的方式就实现了**确保表中的每列都和主键相关，一张表只保存一种数据**的目的。

### 三.第三范式(3NF)

------

第三范式(3NF)**需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关**。

3NF是对字段的`冗余性`，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即**不存在传递依赖**；

**通过数学推导公式来表达：**

用 A、B、C、D 来表示表中的四个列，其中 A 为主键，其中 B → A(B依赖A)， C → A，D → A，如果还有 B → C, C → D 从这两个还可以推导出 B → D, 此时虽然满足第二范式(2NF)，但是不满足第三范式。

> 以“学生”表为例：

| **stuId** | **stuName** | **age** | sex  | **classId** | **className** | **classInfo** |
| --------- | ----------- | ------- | ---- | ----------- | ------------- | ------------- |
| 1         | 小朱        | 23      | m    | 4           | 一班          | 45            |
| 1         | 小朱        | 23      | f    | 4           | 一班          | 45            |
| 2         | 小鲁        | 36      | f    | 2           | 五班          | 45            |
| 3         | 小张        | 18      | m    | 5           | 二班          | 48            |

这张表的主键是 `stdId`，因为这个属性能够确定这张表的其他属性，通过 `stdId` 就可以知道学生姓名、年龄、性别、班级编号、班级名称、班级人数信息。但是仔细观察可以发现，班级名称、班级人数还可以通过 `classId` 确定，而 `classId` 是非主属性，这样就存在了一个传递依赖，并且造成数据的冗余。

解决这个问题就需要将上述表拆成“学生”表和“班级”表，一张表记录学生信息，另一张表记录班级信息，两张表通过**外键**进行关联：

> 学生表：

| **stuId** | **stuName** | **age** | sex  | **classId** |
| --------- | ----------- | ------- | ---- | ----------- |
| 1         | 小朱        | 23      | m    | 4           |
| 1         | 小朱        | 23      | f    | 4           |
| 2         | 小鲁        | 36      | f    | 2           |
| 3         | 小张        | 18      | m    | 5           |

> 班级表：

| **classId** | **className** | **classInfo** |
| ----------- | ------------- | ------------- |
| 4           | 一班          | 45            |
| 4           | 一班          | 45            |
| 2           | 五班          | 45            |
| 5           | 二班          | 48            |

> 调整后的模型如下：

![stu-class.png](https://cdn.jsdelivr.net/gh/zhu325/markdown-img/blog/44430b3da5d143f0bb75730bd7ad69f1~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp)

### 四.反范式化

------

#### 范式化是什么？

在讨论反范式化之前，有必要先明确什么是范式化，要反的东西是什么？

> Database normalization is the process of structuring a relational database in accordance with a series of so-called normal forms in order to reduce data redundancy and improve data integrity.

#### 范式化的弊端

在这些设计范式的约束下，*相关联的信息被存储到了不同的逻辑表中*

以致于经常需要多表联查（`join`操作），关系越复杂，连表查询越慢

> If these relations are stored physically as separate disk files, completing a database query that draws information from several relations (a join operation) can be slow. If many relations are joined, it may be prohibitively slow.

那么，有办法能改善查询性能吗？

有。引入冗余：

- 允许 DBMS 存储额外的冗余信息，例如索引视图（indexed views）、物化视图（materialized views），但仍遵从设计范式
- 增加冗余数据，减少`join`操作，打破设计范式（即*反范式化*）

#### 反范式化是什么？

所谓反范式化，是一种针对遵从设计范式的数据库（关系模式）的性能优化策略

> Denormalization is a strategy used on a previously-normalized database to increase performance.

P.S.注意，*反范式化不等于非范式化*（Unnormalized form），反范式化一定发生在满足范式设计的基础之上。前者相当于先遵守所有规则，再进行局部调整，故意打破一些规则，而后者全然不顾规则

通过增加冗余数据或对数据进行分组，*牺牲一部分写入性能，换取更高的读取性能*：

> In computing, denormalization is the process of trying to improve the read performance of a database, at the expense of losing some write performance, by adding redundant copies of data or by grouping data.

在设计范式的约束下，数据表中没有冗余信息（某个数据只存放在某张表的某个单元格中），为了得到某个数据可能需要一系列的跨表查询，因而读操作性能不佳，但写操作很快，因为更新数据时只需要修改一处

反范式化就是要打破这种约束，*把某些数据在不同的地方多放几份*，以加快数据检索速度：

> The opposite of normalization, denormalization is the process of putting one fact in many places.

#### 具体操作

**具体地，常见做法如：**

- 存一些派生数据：*类似于往 Redux Store 中塞计算属性*，把需要频繁重复计算的结果存起来，例如在一对多关系中，把“多”的数量作为“一”的属性存储起来
- 预先连接（pre-joined）生成汇总表：把需要频繁`join`的表提前`join`好
- 采用硬编码值：把依赖表中的常量值（或者不经常变化的值）直接硬编码到当前表中，从而避免`join`操作
- 把详情信息纳入主表中：对于数据量不大的详情表，可以把全部/部分详情信息塞到主表中，以避免`join`操作

P.S.关于反范式化具体做法的更多信息，见When and How You Should Denormalize a Relational Database

#### 反范式化的代价

但除非必要，一般不建议反范式化，因其代价高昂：

- 失去了数据完整性保障：打破范式，意味着之前通过范式化解决的更新、插入、删除异常问题又将重新冒出来，也就是说，*冗余数据的一致性要靠 DBA 自己来保证*，而不像索引视图等由 DBMS 来保证
- 牺牲了写入速度：由于反范式化引入了冗余数据，更新时要修改多处，但大多数场景都是读密集的，写入慢一点问题不大
- 浪费了存储空间：存储了不必要的冗余数据，自然会浪费一些存储空间，但空间换时间一般是可接受的（毕竟内存、硬盘等资源已经相对廉价了）

P.S.一般通过约束规则（`constraints`）来保证冗余数据的一致性，但这些规则又会抵消一部分作用



### 总结

------

数据库连接会带来一部分的性能损失，并不是数据库范式越高越高，有时会在数据冗余与范式之间做出权衡，在实际的数据库开发过程中，往往会允许一部分的数据冗余来减少数据库连接

**参考链接**

- [数据库三范式详解](https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fxwdreamer%2Farchive%2F2012%2F05%2F17%2F2506039.html)
- [数据库设计三个范式](https://link.juejin.cn/?target=https%3A%2F%2Fningg.top%2Fdatabase-nf%2F)

 
